<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Tiny Farm — Canvas Demo</title>
<style>
  :root{font-family:system-ui, -apple-system, 'Segoe UI', Roboto, 'Hiragino Kaku Gothic ProN', 'Noto Sans JP';}
  html,body{height:100%;margin:0;background:#eef6ea;color:#222}
  #ui{position:absolute;left:12px;top:12px;z-index:10}
  #toolbar{display:flex;gap:6px;margin-bottom:8px}
  button.tool{padding:8px 10px;border-radius:8px;border:1px solid #c8e0b6;background:#fff;cursor:pointer}
  button.tool.selected{box-shadow:0 0 0 3px rgba(104,169,80,.15);border-color:#68a950}
  #status{background:rgba(255,255,255,.85);padding:8px;border-radius:8px;border:1px solid #ddd}
  #status .inner{display:flex;align-items:center;gap:6px;background: #7cff7c;}
  canvas{display:block;width:100vw;height:100vh}
  #legend{position:absolute;right:12px;top:12px;background:rgba(255,255,255,.85);padding:8px;border-radius:8px;border:1px solid #ddd}
</style>
</head>
<body>
<div id="ui">
  <div id="toolbar"></div>
  <div id="status">
    <div class="inner"></div>
  </div>
</div>
<div id="legend">
  <div><strong>操作</strong></div>
  <div>クリック：選択中のツールでタイルを操作</div>
  <div>ツール：Plant / Water / Spray / Harvest / Hoe</div>
</div>
<canvas id="game"></canvas>
<script>
(() => {
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  let DPR = Math.min(window.devicePixelRatio || 1, 2);
  function resize(){
    canvas.width = innerWidth * DPR;
    canvas.height = innerHeight * DPR;
    canvas.style.width = innerWidth + 'px';
    canvas.style.height = innerHeight + 'px';
    TILE_SIZE = Math.floor(Math.min(canvas.width/GRID_W, canvas.height/GRID_H));
  }

  // --- CONFIG ---
  const GRID_W = 8, GRID_H = 6; // タイル数
  let TILE_SIZE = 64 * DPR;
  const SEED_TYPES = {
    carrot: {name:'ニンジン', growthStages:3, baseTime:8},
    tomato: {name:'トマト', growthStages:4, baseTime:12}
  };

  // --- GAME STATE ---
  const tiles = []; // each: {planted, seed, stage, wateredTimer, moisture, pestTimer}
  const inventory = {carrot:6,tomato:4};
  let money = 0;
  let selectedTool = 'plant';
  let selectedSeed = 'carrot';
  let lastTime = performance.now();
  let energy = 20, maxEnergy = 20; // actions cost energy -> prevents infinite idle clicking

  for(let y=0;y<GRID_H;y++){
    for(let x=0;x<GRID_W;x++){
      tiles.push({x,y,planted:false,seed:null,stage:0,progress:0,wateredTimer:0,moisture:1,pest:0});
    }
  }

  // --- UI ---
  const toolbar = document.getElementById('toolbar');
  const status = document.getElementById('status');
  const tools = [
    {id:'plant',label:'Plant'},
    {id:'water',label:'Water'},
    {id:'spray',label:'Spray'},
    {id:'harvest',label:'Harvest'},
    {id:'hoe',label:'Hoe'}
  ];
  function buildToolbar(){
    toolbar.innerHTML='';
    tools.forEach(t=>{
      const b = document.createElement('button');
      b.className='tool'+(selectedTool===t.id?' selected':'');
      b.textContent = t.label;
      b.onclick = ()=>{selectedTool = t.id; updateToolbar();}
      toolbar.appendChild(b);
    });
    // seed selector
    const seedSel = document.createElement('select');
    seedSel.onchange = e=> selectedSeed = e.target.value;
    Object.keys(SEED_TYPES).forEach(k=>{
      const o = document.createElement('option'); o.value=k; o.textContent = SEED_TYPES[k].name + ' ('+ (inventory[k]||0) +')';
      seedSel.appendChild(o);
    });
    toolbar.appendChild(seedSel);
  }
  function updateToolbar(){
    buildToolbar();
  }
  buildToolbar();

  // --- HELPERS ---
  function tileAt(px,py){
    const x = Math.floor(px / TILE_SIZE);
    const y = Math.floor(py / TILE_SIZE);
    if(x<0||x>=GRID_W||y<0||y>=GRID_H) return null;
    return tiles[y*GRID_W + x];
  }

  function useEnergy(cost){
    if(energy < cost) return false;
    energy -= cost;
    tekiouEnergy();
    return true;
  }
  function tekiouEnergy(){
    // statusのinnerのwidthをenergy/max energyの割合にする
    let inner = status.querySelector('.inner');
    inner.style.width = `${(energy/maxEnergy)*100}%`;
  }

  // --- INPUT ---
  canvas.addEventListener('click', e=>{
    const rect = canvas.getBoundingClientRect();
    const px = (e.clientX - rect.left) * DPR;
    const py = (e.clientY - rect.top) * DPR;
    const t = tileAt(px,py);
    if(!t) return;
    // action cost
    const cost = (selectedTool==='water')?1: (selectedTool==='plant')?2: (selectedTool==='spray')?1: (selectedTool==='harvest')?0:1;
    if(!useEnergy(cost)) return; // not enough energy

    if(selectedTool === 'plant'){
      if(t.planted){return}
      if(inventory[selectedSeed] > 0){
        inventory[selectedSeed]--;
        t.planted = true; t.seed = selectedSeed; t.stage = 0; t.progress = 0; t.wateredTimer = 0; t.pest = 0; t.moisture = 0.4;
      }
    } else if(selectedTool === 'water'){
      if(t.planted){ t.wateredTimer = 10; t.moisture = 1; }
    } else if(selectedTool === 'spray'){
      if(t.pest > 0){ t.pest = 0; }
    } else if(selectedTool === 'harvest'){
      if(t.planted && t.stage >= SEED_TYPES[t.seed].growthStages - 1){
        // harvest yield
        const yieldAmount = 1 + Math.floor(Math.random()*2);
        inventory[t.seed] = (inventory[t.seed]||0) + yieldAmount;
        money += 5 * yieldAmount;
        t.planted = false; t.seed = null; t.stage = 0; t.progress = 0; t.wateredTimer = 0; t.moisture = 1; t.pest = 0;
      }
    } else if(selectedTool === 'hoe'){
      // remove planted/unwanted
      t.planted = false; t.seed = null; t.stage = 0; t.progress = 0; t.wateredTimer = 0; t.moisture = 1; t.pest = 0;
    }
  });

  // touch support: treat touchend like click
  canvas.addEventListener('touchend', e=>{ e.preventDefault(); const touch = e.changedTouches[0]; const rect = canvas.getBoundingClientRect(); const px = (touch.clientX - rect.left) * DPR; const py = (touch.clientY - rect.top) * DPR; const t = tileAt(px,py); if(t){ canvas.dispatchEvent(new MouseEvent('click',{clientX:touch.clientX,clientY:touch.clientY})); } });

  // --- GAME UPDATE ---
  function update(dt){
    // energy regen
    energy = Math.min(maxEnergy, energy + dt * 0.5);
    tekiouEnergy();
    // each tile
    tiles.forEach(t=>{
      // moisture evaporates
      t.moisture = Math.max(0, t.moisture - dt*0.02);
      if(t.wateredTimer > 0){ t.wateredTimer -= dt; }
      // pests spawn if neglected
      if(t.planted && t.moisture < 0.2 && t.pest === 0){
        if(Math.random() < 0.003 * dt) t.pest = 1; // small chance
      }
      // growth: only while recently watered (wateredTimer > 0) and no pest
      if(t.planted && t.wateredTimer > 0 && t.pest === 0){
        const seedCfg = SEED_TYPES[t.seed];
        const timeToStage = seedCfg.baseTime; // seconds per stage
        t.progress += dt / timeToStage; // normalized progress
        if(t.progress >= 1){ t.progress = 0; t.stage = Math.min(seedCfg.growthStages-1, t.stage+1); }
      }
    });
  }

  // --- RENDER ---
  function draw(){
    ctx.clearRect(0,0,canvas.width,canvas.height);
    // background
    ctx.fillStyle = '#cfe6b9';
    ctx.fillRect(0,0,canvas.width,canvas.height);

    // grid
    for(let y=0;y<GRID_H;y++){
      for(let x=0;x<GRID_W;x++){
        const i = y*GRID_W + x;
        const t = tiles[i];
        const px = x * TILE_SIZE + 4*DPR;
        const py = y * TILE_SIZE + 4*DPR;
        const w = TILE_SIZE - 8*DPR;
        const h = TILE_SIZE - 8*DPR;
        // soil
        ctx.fillStyle = '#8b6b4e';
        ctx.fillRect(px,py,w,h);
        // moisture overlay
        if(t.moisture > 0){ ctx.fillStyle = `rgba(120,180,250,${Math.min(0.6,t.moisture*0.6)})`; ctx.fillRect(px,py,w,h); }
        // planted
        if(t.planted){
          // plant base
          const cfg = SEED_TYPES[t.seed];
          const stage = t.stage;
          const plantH = Math.max(8, (stage+1) / cfg.growthStages * (h-12));
          ctx.fillStyle = '#1b5e20';
          ctx.fillRect(px + w*0.25, py + h - plantH - 8*DPR, w*0.5, plantH);
          // fruit indicator
          if(stage >= cfg.growthStages-1){ ctx.fillStyle = '#ff6b6b'; ctx.beginPath(); ctx.arc(px+w*0.5, py + h - plantH - 12*DPR, 8*DPR,0,Math.PI*2); ctx.fill(); }
        }
        // pest
        if(t.pest){ ctx.fillStyle='rgba(0,0,0,0.6)'; ctx.font = `${12*DPR}px sans-serif`; ctx.fillText('害虫', px+6*DPR, py+14*DPR); }
        // tile border
        ctx.strokeStyle = 'rgba(0,0,0,0.12)'; ctx.strokeRect(px,py,w,h);
      }
    }

    // HUD
    ctx.save();
    ctx.scale(12/DPR,12/DPR); // draw HUD in CSS pixels
    ctx.fillStyle = '#222';
    ctx.fillText(`Money: ¥${money}`, 12, 24);
    ctx.fillText(`Energy: ${Math.floor(energy)}/${maxEnergy}`, 12, 40);
    // inventory
    let invStr = 'Inventory:';
    Object.keys(inventory).forEach(k=> invStr += ` ${SEED_TYPES[k].name}×${inventory[k]}`);
    ctx.fillText(invStr, 12, 60);
    ctx.restore();
  }

  function loop(now){
    const dt = Math.min(1/15, (now - lastTime)/1000);
    lastTime = now;
    update(dt);
    draw();
    requestAnimationFrame(loop);
  }

  // --- start ---
  resize();
  window.addEventListener('resize', resize);
  requestAnimationFrame(loop);

  // expose for debug
  window.__TINYFARM = {tiles,inventory,SEED_TYPES};
})();
</script>
</body>
</html>
